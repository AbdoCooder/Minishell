@startuml MinishellMainCommandLoop

start

:Initialize signals with handle_signals();
:Initialize environment with ft_envinit();

while (Main Loop) is (continue)
  :Display prompt with readline();
  note right: "minishell-1.0$ "

  :Read input from user;

  if (input == NULL?) then (yes)
    :Print "[EOF]" and exit;
    stop
  endif

  if (input is empty?) then (yes)
    :Continue to next iteration;
  else (no)
    :Add input to history with add_history();

    :Tokenize input with ft_strtok();
    note right: Creates t_token linked list\nHandles quotes, operators, words

    :Check syntax with ft_check_syntax();
    if (syntax error?) then (yes)
      :Print error message;
      :Set g_exit_status = 258;
      :Free token list with ft_free_tokenlist();
    else (no)
      :Parse tokens with ft_parser();
      note right: Creates t_cmdarg linked list\nExpands variables with ft_expand_variables()\nHandles redirections

      :Check heredocs with check_here_doc();
      if (heredoc error?) then (yes)
        :Cleanup and continue;
      else (no)

        :Check if single builtin with check_builtin();
        if (single builtin?) then (yes)
          :Handle builtin redirections;
          :Execute builtin command;
          :Reset standard I/O;
          :Update g_exit_status;
        else (no)
          :Execute pipeline with execution();

          while (commands in pipeline?) is (more commands)
            if (not last command?) then (yes)
              :Create pipe with pipe();
            endif

            :Fork child process;
            if (child process?) then (yes)
              :Setup child signals;
              :Handle input redirection;
              if (not last command?) then (yes)
                :Redirect stdout to pipe;
              endif
              :Handle output redirection;

              if (builtin in child?) then (yes)
                :Execute builtin;
                :Exit with status;
              else (no)
                :Resolve command path with check_exec();
                :Get environment array;
                :Execute with execve();
              endif
            else (parent process)
              :Close unused pipe ends;
              :Update input fd for next command;
            endif
          endwhile (no more commands)

          :Setup parent waiting signals;
          :Wait for all children with ft_wait_children();
          :Update g_exit_status from last command;
          :Restore signals;
        endif
      endif
    endif

    :Cleanup with ft_cleaner();
    note right: Frees token_list and cmdarg_list
  endif

  :Free input string;
endwhile (exit)

stop

note top of start : "Main entry point in main()\nContinuous REPL loop"

note right of "Tokenize input with ft_strtok()" : "Lexical analysis:\n- Handle quotes (single/double)\n- Identify operators (|, <, >, <<, >>)\n- Parse words and variables\n- Create doubly-linked token list"

note right of "Parse tokens with ft_parser()" : "Syntax analysis:\n- Group tokens into commands\n- Handle redirections\n- Create command pipeline\n- Expand environment variables"

note right of "Check heredocs with check_here_doc()" : "Heredoc processing:\n- Fork for each heredoc\n- Read until delimiter\n- Handle variable expansion\n- Store in temporary files/pipes"

note right of "Execute pipeline with execution()" : "Process management:\n- Create pipes between commands\n- Fork for each command\n- Handle I/O redirections\n- Wait for process completion"

@enduml
      else (no)
        :Check if builtin with check_builtin();
        if (single builtin command?) then (yes)
          :Handle builtin redirections;
          :Execute builtin with run_built_in();
          :Update g_exit_status;
          :Reset stdout/stdin if needed;
        else (external or piped)
          :Execute with execution();

          partition "Execution Flow" {
            :Initialize tmp_in = 0;
            :current_cmd = first command;

            while (more commands?) is (yes)
              if (has next command?) then (yes)
                :Create pipe with pipe();
              endif

              :Fork process with fork();

              if (child process?) then (yes)
                :Setup child signals;
                :Setup pipe redirections with dup2();
                :Close unused pipe ends;
                :Handle input redirections;
                :Handle output redirections;

                if (is builtin?) then (yes)
                  :Execute builtin and exit;
                else (external)
                  :Resolve command path with check_exec();
                  :Get environment with get_env();
                  :Execute with execve();
                endif

              else (parent)
                :Close unused pipe ends;
                :Update tmp_in for next iteration;
                :Close heredoc fds;
              endif

              :Move to next command;
            endwhile

            :Setup parent waiting signals;
            :Wait for all children with ft_wait_children();
            :Update g_exit_status from last child;
            :Restore original signals;
          }
        endif
      endif
    endif

    :Cleanup with ft_cleaner();
    note right: Free token list and cmdarg list
  endif

  :Free input string;
endwhile

stop

@enduml
