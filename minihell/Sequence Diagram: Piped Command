@startuml MinishellPipedCommandSequence

!define KERNEL participant
!define SHELL participant
!define PARSER participant
!define EXECUTOR participant
!define CHILD1 participant
!define CHILD2 participant

participant "Main Shell" as SHELL
participant "Parser" as PARSER
participant "Executor" as EXECUTOR
participant "Child Process 1\n(ls -l)" as CHILD1
participant "Child Process 2\n(grep .c)" as CHILD2
participant "Kernel" as KERNEL


participant "Child1 (ls)" as Child1
participant "Child2 (grep)" as Child2
participant "Kernel" as Kernel
participant "Parent Process" as Parent

User -> Main: Enter "ls -l | grep .c"
activate Main

Main -> Main: readline() input
Main -> Main: add_history()
Main -> Parser: ft_strtok()
activate Parser
Parser -> Parser: Create token list\n[WORD:"ls", WORD:"-l", PIPE, WORD:"grep", WORD:".c"]
Parser --> Main: token_list
deactivate Parser

Main -> Main: ft_check_syntax()
note right: Validates pipe syntax

Main -> Parser: ft_parser()
activate Parser
Parser -> Parser: Create cmdarg_list:\nCmd1: ["ls", "-l"]\nCmd2: ["grep", ".c"]
Parser --> Main: cmdarg_list
deactivate Parser

Main -> Main: check_here_doc()
note right: No heredocs in this example

Main -> Main: check_builtin()
note right: Not a single builtin

Main -> Exec: execution(cmdarg_list)
activate Exec

' First command execution
Exec -> Exec: current_cmd = "ls -l"
Exec -> Kernel: pipe(pip_fd)
Kernel --> Exec: pip_fd[0,1] created

Exec -> Kernel: fork()
Kernel --> Exec: pid1

alt Child Process 1 (ls)
  Exec -> Child1: Child process starts
  activate Child1
  Child1 -> Child1: setup_child_signals()
  Child1 -> Kernel: dup2(pip_fd[1], STDOUT_FILENO)
  note right: Redirect stdout to pipe
  Child1 -> Kernel: close(pip_fd[0])
  Child1 -> Kernel: close(pip_fd[1])
  Child1 -> Child1: handle_input/output redirections
  Child1 -> Child1: check_exec("ls")
  Child1 -> Kernel: execve("/bin/ls", ["ls", "-l"], envp)
  note right: ls process replaces child1
  deactivate Child1
else Parent Process
  Parent -> Parent: close(pip_fd[1])
  Parent -> Parent: tmp_in = pip_fd[0]
end

' Second command execution
Exec -> Exec: current_cmd = "grep .c"
Exec -> Kernel: fork()
Kernel --> Exec: pid2

alt Child Process 2 (grep)
  Exec -> Child2: Child process starts
  activate Child2
  Child2 -> Child2: setup_child_signals()
  Child2 -> Kernel: dup2(tmp_in, STDIN_FILENO)
  note right: Redirect stdin from pipe
  Child2 -> Kernel: close(tmp_in)
  Child2 -> Child2: handle_input/output redirections
  Child2 -> Child2: check_exec("grep")
  Child2 -> Kernel: execve("/bin/grep", ["grep", ".c"], envp)
  note right: grep process replaces child2
  deactivate Child2
else Parent Process
  Parent -> Parent: close(tmp_in)
end

' Wait for children
Exec -> Exec: setup_parent_waiting_signals()
Exec -> Kernel: wait() for all children
note right: Wait for ls and grep to complete

Kernel --> Exec: Child exit statuses
Exec -> Exec: Update g_exit_status from last child
Exec -> Exec: restore_signals()

Exec --> Main: execution complete
deactivate Exec

Main -> Main: ft_cleaner()
note right: Free all allocated memory

Main --> User: Display results and prompt
deactivate Main

@enduml
